# Package Mode Support Plan for Magic Stubs

## Current stub inventory overview
- **PHP support scaffolding** — `stubs/magic/app` contains reusable helpers such as the `HasName` trait, `ApiResponse` value object, and an opinionated `HandleInertiaRequests` middleware that adds flash data and sidebar state handling. These are written in the `App` namespace and expect to live inside a host application's `app/` tree.
- **Frontend assets** — `stubs/magic/resources` ships the Inertia entry point assets: the `app.blade.php` root view, the Tailwind-based `resources/css/app.css`, and the Vue 3 component library plus composables under `resources/js/**`.
- **Build tooling** — `stubs/magic/scripts/generate-ui-index.mjs` is invoked from `InstallNodePackagesAction` to keep the shadcn component barrel file in sync, and `stubs/magic/tests/Fixtures/test_file.txt` exercises file-copy behaviour in tests.

## Package-mode gaps
1. **PHP helpers never reach package builds.** `PublishFilesAction::copyMagicFiles()` currently skips everything under `stubs/magic` when `BuildContext::isPackageBuild()` is true, leaving generated models referencing `MagicNamespaces::traits('HasName')` without an actual trait class in the package (`stubs/magic/app/Traits/HasName.php`). The same applies to `ApiResponse` and `HandleInertiaRequests`, so package consumers miss required middleware and response types.
2. **Namespace and directory assumptions are host-app specific.** The `stubs/magic/app` files are hard-coded to the `App\…` namespace and expect to live in an `app/` directory. Package builds route `MagicPaths::app()` to `src/`, so the files must be rewritten into the custom base namespace instead of copying raw PHP files.
3. **Frontend scaffolding is not published for packages.** Vue, CSS, and Blade assets under `stubs/magic/resources/**` are essential for the CRUD UI, but the package service provider only loads views/migrations and never publishes the assets. Package builds therefore install without the compiled frontend entrypoints in the host application.
4. **Tooling scripts need relocation.** The `scripts/generate-ui-index.mjs` helper should ship with packages so consumers can re-run it, but the current skip logic omits it. It also assumes the script sits at the project root, which differs inside a Composer package.

## Proposed remediation plan
1. **Refactor Magic support copying into targeted pipelines.** Replace the blanket directory copy with logic that maps the top-level folders to the appropriate package-aware destinations (`MagicPaths::app('Traits/…')`, `MagicPaths::resource('js/…')`, etc.). When `BuildContext::isPackageBuild()` is true, the same mapping will place files under `src/` and `resources/` inside the package rather than creating a forbidden `app/` tree.
2. **Introduce namespace-aware PHP stubs.** Convert `stubs/magic/app/*.php` into stub templates (e.g., `HasName.php.stub`) that interpolate `MagicNamespaces::traits()` / `MagicNamespaces::responses()` so the copied files adopt the configured base namespace. Ensure the generator only materialises them when missing so package builds stay idempotent.
3. **Publish frontend assets from the package.** Extend the generated service provider to call `$this->publishes()` for CSS, JS, and the Inertia root view, and ensure the resources are copied into the package build output. Document the publish tags so consuming apps can pull the assets into their own `resources/` directory before running Vite.
4. **Ship utility scripts and fixtures with adjusted paths.** Copy `stubs/magic/scripts` into the package root (or a dedicated `scripts/` folder) and update any references (such as in `InstallNodePackagesAction`) to use `MagicPaths::base('scripts/...')` so both host and package builds can execute the same script layout.
5. **Add regression coverage.** Create package-mode tests that assert the generated package contains the namespaced trait, response, middleware, frontend resources, and scripts. This guards against future regressions when tweaking `PublishFilesAction` or stub layouts.
